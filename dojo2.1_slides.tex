\documentclass{beamer}
\usepackage{hyperref}
\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks,linkcolor=,urlcolor=links}

\usepackage{verbatim}

\title{Haskell Dojo 2}
\subtitle{Taking it to practice}
\date{\today}
\author{Janne Haskell}

\begin{document}

\frame{\titlepage}

%-----------------------------------------------------------------
\begin{frame}[fragile]

\frametitle{Haskell Dojo 2}

We will incrementally work on an example project that demonstrates:

\begin{itemize}
  \item Basic project setup and compilation
  \item Parsing JSON
  \item I/O (working in the IO monad, networking)
  \item Monad basics
  \item Handling state in a pure language (game state, state monad)
\end{itemize}

\end{frame}
%-----------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Resources}

Links:

\begin{itemize}
  \item \href{https://github.com/nurpax/haskell-dojo/wiki/Haskell-Dojo-\%232}{Dojo wiki}
  \item \href{http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program}{Excellent starter guide}
\end{itemize}

\end{frame}

%-----------------------------------------------------------------
\begin{frame}[fragile]

\frametitle{Today}

Today we will practice:

\begin{itemize}
  \item How to setup and build a Haskell project
  \item How to parse JSON
\end{itemize}

\end{frame}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\begin{frame}[fragile]

\frametitle{Project setup}

Haskell projects are built using {\em cabal}

\begin{itemize}
  \item Think ``make'' for Haskell
  \item Your project details are declared with a {\em .cabal} file.
\end{itemize}

A {\em .cabal} file contains:
\begin{itemize}
  \item What source files make up your project
  \item What libraries are you linking against
  \item ..plus other stuff which you can mostly just copy\&paste over
\end{itemize}

% TODO move to a later slide?
\medskip
See the Haskell wiki on \href{http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program}{How
  to write a Haskell program} for a more comprehensive guide.

\end{frame}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Interactive - let's try it}

Let's create an executable project with source code under \verb|src/|
\medskip

Run the below and respond to the interactive prompts:

\begin{verbatim}
mkdir test-project  # do not use underscore here!
cd test-project
mkdir src
cabal init -m
\end{verbatim}

Create a source file \verb|src/Main.hs| with contents:

\begin{verbatim}
main :: IO ()
main = putStrLn "Hello world from Haskell"
\end{verbatim}

\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Interactive - let's try it}
Let cabal know which module contains your \verb+main+ by editing the .cabal file:

\begin{verbatim}
$ diff -u test-project.cabal.orig test-project.cabal
--- test-project.cabal.orig     Tue Oct 30 20:36:16 2012
+++ test-project.cabal  Tue Oct 30 20:35:38 2012
@@ -9,4 +9,5 @@

 executable test-project
   build-depends:       base ==4.5.*
+  main-is:             Main.hs
   hs-source-dirs:      src
\end{verbatim}

\end{frame}

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Interactive - build and run}

Your example project is now ready to be built:

\begin{verbatim}
cabal configure
cabal build
\end{verbatim}

To run it:
\begin{verbatim}
$ ./dist/build/test-project/test-project
Hello world from Haskell
\end{verbatim}

\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Creating another module}

Anything more complex than a ``hello world'' world app will have more
than one module.  So let's try creating another module called {\em Types}.

\bigskip
Add a new file \verb+src/Types.hs+ with the following in it:

\begin{verbatim}
module Types (
    Suit(..)
  ) where

data Suit = Hearts | Spades | Diamonds | Clubs
    deriving (Show, Eq, Ord)
\end{verbatim}

\end{frame}

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Using your Types module}

Let's use the new module in your \verb+Main+ module.  Replace your \verb+src/Main.hs+ with this:

\begin{verbatim}
import Types

main :: IO ()
main = print Hearts
\end{verbatim}

Try running it:

\begin{verbatim}
$ cabal build
$ ./dist/build/test-project/test-project
Hearts
\end{verbatim}

\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{A bit of practice}

Load ``Main.hs'' into ghci for interactive poking around.

\bigskip

Exercise 1.  Given the below list of Cards, count how many hearts are
in it?

\begin{verbatim}
h = Card Hearts
s = Card Spades
d = Card Diamonds
c = Card Clubs

cs :: [Card]
cs = [d 3, d 2, h 4, h 3, s 1, h 5]
\end{verbatim}


\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Solutions}

A few variants:

{\small
\begin{verbatim}
length . filter (\s -> Hearts == suit s) $ cs

foldr (\c acc -> acc + if suit c == Hearts then 1 else 0) 0 cs

sum [1 | c <- cs, suit c == Hearts]
\end{verbatim}
}

\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{HLint}

HLint is a cool tool that'll automatically review your code.

\bigskip
Code shouldn't be put up for code review before it's been HLint'd.
This resolves a lot of coding convention debates. :)

\bigskip
Installation:
\begin{verbatim}
cabal install hlint
\end{verbatim}

\end{frame}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{HLint}

Examples of things it can do:

\begin{itemize}
  \item Suggest better use of library functions
  \item Point out unnecessary lambdas, parenthesis, do statements, etc.
  \item Suggest monadic simplifications or generalizations (like
    function composition, fmap, mapM vs mapM\_, etc.)
\end{itemize}
\bigskip

It's good to get into the habit of using it to get your computer to
give you good Haskell coding tips.

\end{frame}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{HLint, examples}

\verbatiminput{hlint-ex.hs}

\end{frame}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Moving on..}

On to parsing JSON..
\bigskip

Exercise project bots will be talking JSON with the server.  So how to
parse it?

\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Cards as JSON}

Problem: how to turn strings like this:
\bigskip

{\small
\begin{verbatim}
{ "suit": "hearts", "rank": 1 }
{ "suit": "spades", "rank": 2 }
{ "suit": "diamonds", "rank": 3 }
{ "suit": "clubs", "rank": 4 }
\end{verbatim}
}
..into Haskell data:

{\small
\begin{verbatim}
Card {suit = Hearts, rank = 1}
Card {suit = Spades, rank = 2}
Card {suit = Diamonds, rank = 3}
Card {suit = Clubs, rank = 4}
\end{verbatim}
}

\end{frame}
%-----------------------------------------------------------------


%-----------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{How to go from a string to Haskell data?}

Usually transforming strings to data works like this:
\begin{enumerate}
\item Parse the string into an abstract syntax tree (AST)
\item Walk the AST and construct a Haskell data structure out of the
  AST nodes
\end{enumerate}

Both steps usually involve some type of data conversion and error
checking.

\end{frame}
%-----------------------------------------------------------------

%-----------------------------------------------------------------
% TODO show AST (Riku's JSON type)
% TODO show his parser too, but don't go into details
% TODO walk the tree to construct a Card

\end{document}
